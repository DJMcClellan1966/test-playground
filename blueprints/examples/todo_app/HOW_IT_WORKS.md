# How This App Was Built

This document explains **every architectural decision** so you understand not just what the code does, but **why** it was built this way.

---

## 1. The Requirements

You said: *"I want a todo app"*

The system extracted these **constraints**:
- Needs to store data → requires **storage**
- Needs to list/create/update/delete → requires **CRUD operations**
- Should work in a browser → requires **web backend**
- Single user for now → **no auth needed** (yet)

---

## 2. How Constraints Became Decisions

```
Constraint                    → Decision
─────────────────────────────────────────────────────
needs_storage=true           → storage_json block
  ↳ Why JSON? Simplest for dev. Upgradeable to SQLite/Postgres later.

needs_crud=true              → crud_routes block  
  ↳ Generates REST endpoints automatically.

needs_web=true               → backend_flask block
  ↳ Why Flask? Simpler than FastAPI for beginners. Same patterns.

multi_user=false             → No auth block
  ↳ Adding users later just requires adding auth_basic block.
```

---

## 3. The Code Structure Explained

### `app.py` - The Main File

```
Lines 1-16:    Setup (Flask app, CORS, secret key)
               ↳ Why CORS? So JavaScript can call the API.
               ↳ Why secret_key? Flask sessions need it.

Lines 22-42:   Storage Functions
               ↳ load_tasks(): Read from JSON file
               ↳ save_tasks(): Write to JSON file
               ↳ Why functions? Easy to swap for database later.

Lines 48-130:  API Routes
               ↳ Standard REST: GET/POST/PUT/DELETE
               ↳ Each returns JSON for the frontend

Lines 136-280: HTML Template
               ↳ Inline HTML+CSS+JS (one file = simpler demo)
               ↳ Production would use separate files

Lines 380-397: Server Startup
               ↳ Debug mode for development
               ↳ Port 5000 (Flask default)
```

---

## 4. Why Each Design Choice?

### Why JSON file storage?
- **Pros**: Zero setup, human-readable, good for demos
- **Cons**: Doesn't scale, no concurrent writes
- **Upgrade path**: Change to `storage_sqlite` block for production

### Why Flask instead of FastAPI?
- **Flask**: Synchronous, simpler, better for learning
- **FastAPI**: Async, faster, better for production
- **Both use same patterns** - switching is easy

### Why inline HTML in Python?
- **Demo simplicity**: One file = easier to understand
- **Production**: Would split into `templates/` folder
- **Same concepts**: Jinja2 templating works either way

### Why no authentication?
- **YAGNI**: You Ain't Gonna Need It (yet)
- **Add later**: Just include `auth_basic` block
- **Constraint-first**: Only add what requirements demand

---

## 5. How to Modify This App

### Add a new field (e.g., due date):
```python
# In create_task():
task = {
    ...
    "due_date": data.get("due_date"),  # Add this line
}
```

### Add user authentication:
```bash
python blueprint.py create "todo app with login"
# This adds the auth_basic block automatically
```

### Switch to SQLite:
Replace the storage functions with the `storage_sqlite` block code.

### Add categories/tags:
```python
task = {
    ...
    "category": data.get("category", "general"),
    "tags": data.get("tags", []),
}
```

---

## 6. The Block Composition

This app uses 3 blocks from the Blueprint library:

| Block | Purpose | Could Be Swapped For |
|-------|---------|---------------------|
| `backend_flask` | Web server | `backend_fastapi` |
| `storage_json` | Data persistence | `storage_sqlite`, `storage_postgres` |
| `crud_routes` | REST endpoints | Custom routes |

**Why blocks?** Each block is tested, proven, and swappable. Learn once, reuse everywhere.

---

## 7. What You Learned

By studying this app, you now understand:

- [x] How Flask apps are structured
- [x] How REST APIs work (GET/POST/PUT/DELETE)
- [x] How to store data in JSON files
- [x] How frontend JavaScript talks to backend Python
- [x] Why constraints drive architecture
- [x] How to extend the app yourself

---

## 8. Next Steps

1. **Modify it**: Add a field, change the styling
2. **Break it**: See what error messages look like
3. **Upgrade it**: Add auth, switch storage
4. **Build your own**: Use `python blueprint.py create "your app"`

---

*Generated by Blueprint Scaffolder - Constraint-First Development*
*"What AI guesses, we prove. What AI builds, we explain."*
