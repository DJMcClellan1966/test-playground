{
  "source": "sources/algorithms_intro.md",
  "mtime": 1770559141.2860494,
  "size": 11005,
  "sections": [
    {
      "title": "1.1 Definition",
      "level": 3,
      "content": "\nAn **algorithm** is a finite sequence of well-defined instructions for solving a class of problems or performing a computation. The word derives from the name of the Persian mathematician Muhammad ibn Musa al-Khwarizmi (c. 780-850 CE).\n\nFor a procedure to qualify as an algorithm, it must satisfy five fundamental properties:\n\n1. **Finiteness**: An algorithm must always terminate after a finite number of steps. A procedure that runs forever is not an algorithm.\n\n2. **Definiteness**: Each step of an algorithm must be precisely defined. The actions to be carried out must be rigorously and unambiguously specified for each case.\n\n3. **Input**: An algorithm has zero or more inputs\u2014quantities that are given to it before the algorithm begins, or dynamically as it runs.\n\n4. **Output**: An algorithm has one or more outputs\u2014quantities that have a specified relation to the inputs.\n\n5. **Effectiveness**: An algorithm's operations must be sufficiently basic that they can, in principle, be done exactly and in a finite length of time by a person using pencil and paper.\n\n"
    },
    {
      "title": "1.2 Algorithms vs. Programs",
      "level": 3,
      "content": "\nAn algorithm is not the same as a program. An algorithm is an abstract concept\u2014a method or procedure. A program is a concrete implementation of an algorithm in a specific programming language. The same algorithm can be implemented in many different programs.\n\nConsider: The algorithm for finding the greatest common divisor of two numbers existed for over 2000 years before any programming language was invented.\n\n"
    },
    {
      "title": "1.3 A First Example: Euclid's Algorithm",
      "level": 3,
      "content": "\nEuclid's algorithm finds the greatest common divisor (GCD) of two positive integers. It is one of the oldest known algorithms, appearing in Euclid's *Elements* around 300 BCE.\n\n**Problem**: Given two positive integers m and n, find their greatest common divisor\u2014the largest positive integer that divides both m and n without remainder.\n\n**Algorithm E (Euclid's algorithm)**:\n\n- **E1.** [Find remainder.] Divide m by n and let r be the remainder. (We have 0 \u2264 r < n.)\n- **E2.** [Is it zero?] If r = 0, the algorithm terminates; n is the answer.\n- **E3.** [Reduce.] Set m \u2190 n, n \u2190 r, and go back to step E1.\n\n**Example**: Find gcd(544, 119).\n\n| Step | m | n | r | Action |\n|------|-----|-----|-----|--------|\n| E1 | 544 | 119 | 68 | 544 = 4\u00d7119 + 68 |\n| E3 | 119 | 68 | \u2014 | Replace m with n, n with r |\n| E1 | 119 | 68 | 51 | 119 = 1\u00d768 + 51 |\n| E3 | 68 | 51 | \u2014 | Replace |\n| E1 | 68 | 51 | 17 | 68 = 1\u00d751 + 17 |\n| E3 | 51 | 17 | \u2014 | Replace |\n| E1 | 51 | 17 | 0 | 51 = 3\u00d717 + 0 |\n| E2 | \u2014 | 17 | 0 | r = 0, so gcd = 17 |\n\n**Verification**: gcd(544, 119) = 17. Indeed, 544 = 17 \u00d7 32 and 119 = 17 \u00d7 7.\n\n"
    },
    {
      "title": "1.4 Why Euclid's Algorithm Works",
      "level": 3,
      "content": "\nThe algorithm relies on a key mathematical property:\n\n**Theorem**: If m = qn + r (where q is the quotient and r is the remainder when m is divided by n), then gcd(m, n) = gcd(n, r).\n\n**Proof**: Any divisor of both m and n must also divide r = m - qn. Conversely, any divisor of both n and r must divide m = qn + r. Therefore, the set of common divisors of (m, n) equals the set of common divisors of (n, r), so their greatest common divisors are equal.\n\nSince r < n at each step, and r \u2265 0, the algorithm must eventually reach r = 0. When r = 0, we have gcd(n, 0) = n, so n is the answer.\n\n"
    },
    {
      "title": "1.5 Properties Verified",
      "level": 3,
      "content": "\nLet us verify that Euclid's algorithm satisfies all five properties:\n\n1. **Finiteness**: The remainder r strictly decreases (since r < n, and n becomes the new r), and r \u2265 0. The sequence of remainders must reach 0 in at most n steps.\n\n2. **Definiteness**: Each step is precisely defined. \"Divide m by n\" has an unambiguous meaning for positive integers. The comparison r = 0 is definite.\n\n3. **Input**: Two positive integers m and n.\n\n4. **Output**: One positive integer, the gcd of m and n.\n\n5. **Effectiveness**: Division, comparison to zero, and assignment are all operations that can be done by hand.\n\n---\n\n"
    },
    {
      "title": "2.1 Why Analyze?",
      "level": 3,
      "content": "\nAnalysis tells us how an algorithm behaves as the problem size grows. Two algorithms that both solve a problem correctly may have vastly different performance. Analysis allows us to:\n\n- **Compare** algorithms objectively\n- **Predict** behavior on large inputs\n- **Identify** bottlenecks and opportunities for improvement\n\n"
    },
    {
      "title": "2.2 Measuring Performance",
      "level": 3,
      "content": "\nWe measure algorithm performance in terms of:\n\n- **Time complexity**: How many operations does it perform?\n- **Space complexity**: How much memory does it use?\n\nWe express these as functions of the input size, typically denoted n.\n\n"
    },
    {
      "title": "2.3 Big-O Notation",
      "level": 3,
      "content": "\n**Definition**: We say f(n) = O(g(n)) if there exist positive constants c and n\u2080 such that f(n) \u2264 c\u00b7g(n) for all n \u2265 n\u2080.\n\nIn plain language: f(n) is O(g(n)) means f grows no faster than g, ignoring constant factors and small inputs.\n\n**Common complexity classes** (from fastest to slowest growth):\n\n| Notation | Name | Example |\n|----------|------|---------|\n| O(1) | Constant | Array access by index |\n| O(log n) | Logarithmic | Binary search |\n| O(n) | Linear | Simple search through a list |\n| O(n log n) | Linearithmic | Efficient sorting (mergesort) |\n| O(n\u00b2) | Quadratic | Simple sorting (bubble sort) |\n| O(2\u207f) | Exponential | Brute-force subset enumeration |\n\n"
    },
    {
      "title": "2.4 Analysis of Euclid's Algorithm",
      "level": 3,
      "content": "\nHow many steps does Euclid's algorithm take?\n\n**Theorem (Lam\u00e9, 1844)**: The number of steps in Euclid's algorithm never exceeds five times the number of digits in the smaller input.\n\nMore precisely, if the algorithm performs k division steps, then the smaller input n must be at least as large as the k-th Fibonacci number.\n\n**Consequence**: Euclid's algorithm is O(log n) where n is the smaller input. This is remarkably efficient\u2014doubling the input size adds only a constant number of steps.\n\n"
    },
    {
      "title": "2.5 Best, Worst, and Average Case",
      "level": 3,
      "content": "\nFor many algorithms, performance varies depending on the specific input:\n\n- **Best case**: The minimum operations for any input of size n\n- **Worst case**: The maximum operations for any input of size n\n- **Average case**: The expected operations over all inputs of size n\n\nFor Euclid's algorithm:\n- **Best case**: r = 0 on the first step (n divides m), so 1 step\n- **Worst case**: Consecutive Fibonacci numbers, approximately 2.078 ln(n) + 1.672 steps\n- **Average case**: Approximately 0.843 ln(n) + 1.47 steps\n\n---\n\n"
    },
    {
      "title": "3.1 What Does Correctness Mean?",
      "level": 3,
      "content": "\nAn algorithm is **correct** if, for every valid input, it:\n1. Terminates (doesn't run forever)\n2. Produces the correct output\n\nCorrectness is not optional. An incorrect algorithm is useless, regardless of how fast it runs.\n\n"
    },
    {
      "title": "3.2 Proving Correctness",
      "level": 3,
      "content": "\nFor Euclid's algorithm, we must prove:\n\n1. **Termination**: The algorithm always stops.\n2. **Partial correctness**: If it stops, the answer is correct.\n\n**Termination proof**: At each iteration, r < n, and n becomes the new value used for the next remainder. Since n decreases and is always a non-negative integer, it must eventually reach a state where r = 0.\n\n**Partial correctness proof**: We use a **loop invariant**\u2014a property that is true before and after each iteration.\n\n**Loop invariant**: gcd(m, n) = gcd(original m, original n)\n\n- **Initialization**: Before the first iteration, this is trivially true.\n- **Maintenance**: If gcd(m, n) = d before an iteration, then after setting m \u2190 n, n \u2190 r, we have gcd(n, r) = gcd(m, n) = d (by the theorem in Section 1.4).\n- **Termination**: When r = 0, gcd(m, n) = n. By the invariant, n = gcd(original m, original n).\n\n"
    },
    {
      "title": "3.3 Defensive Programming",
      "level": 3,
      "content": "\nEven correct algorithms can fail in practice due to:\n\n- **Invalid input**: What if m or n is zero? Negative? Not an integer?\n- **Overflow**: What if m \u00d7 n exceeds the maximum integer size?\n- **Implementation errors**: Typos, off-by-one mistakes, etc.\n\nGood practice: Verify inputs, test edge cases, and use assertions.\n\n---\n\n"
    },
    {
      "title": "4.1 Definition",
      "level": 3,
      "content": "\nA **recursive** algorithm is one that calls itself with a smaller instance of the same problem.\n\nEvery recursive algorithm has:\n1. **Base case(s)**: Inputs for which the answer is immediate, without recursion\n2. **Recursive case(s)**: Inputs that are reduced and the algorithm is called again\n\n"
    },
    {
      "title": "4.2 Euclid's Algorithm, Recursively",
      "level": 3,
      "content": "\nThe iterative Euclid's algorithm can be expressed recursively:\n\n```\ngcd(m, n):\n    if n = 0:\n        return m\n    else:\n        return gcd(n, m mod n)\n```\n\n**Base case**: n = 0, return m\n**Recursive case**: n > 0, return gcd(n, m mod n)\n\n"
    },
    {
      "title": "4.3 How Recursion Works",
      "level": 3,
      "content": "\nEach recursive call creates a new \"frame\" with its own variables. The frames stack up until a base case is reached, then unwind as each call returns.\n\n**Example**: gcd(544, 119)\n\n```\ngcd(544, 119)\n  \u2192 gcd(119, 68)    [544 mod 119 = 68]\n    \u2192 gcd(68, 51)   [119 mod 68 = 51]\n      \u2192 gcd(51, 17) [68 mod 51 = 17]\n        \u2192 gcd(17, 0) [51 mod 17 = 0]\n          \u2192 return 17  [base case]\n        \u2192 return 17\n      \u2192 return 17\n    \u2192 return 17\n  \u2192 return 17\n\u2192 17\n```\n\n"
    },
    {
      "title": "4.4 Recursion vs. Iteration",
      "level": 3,
      "content": "\nAny recursive algorithm can be converted to an iterative one (and vice versa). The choice depends on:\n\n| Factor | Recursion | Iteration |\n|--------|-----------|-----------|\n| Clarity | Often cleaner for naturally recursive problems | Better for simple loops |\n| Efficiency | Overhead from call stack | Generally faster |\n| Space | Uses stack space proportional to recursion depth | Constant extra space |\n| Risk | Stack overflow on deep recursion | None |\n\nFor Euclid's algorithm, both forms are equally clear, but iteration is slightly more efficient.\n\n---\n\n"
    },
    {
      "title": "Section 5: Summary",
      "level": 2,
      "content": "\nThis section introduced:\n\n1. **Definition of algorithm**: A finite, definite, effective procedure with inputs and outputs\n2. **Euclid's algorithm**: An ancient, elegant algorithm for finding the GCD\n3. **Analysis**: Measuring time and space complexity using Big-O notation\n4. **Correctness**: Proving algorithms work using loop invariants\n5. **Recursion**: Algorithms that call themselves on smaller problems\n\nThese concepts form the foundation for studying more complex algorithms and data structures.\n\n---\n\n"
    },
    {
      "title": "Exercises",
      "level": 2,
      "content": "\n1. Trace Euclid's algorithm for gcd(252, 105). How many steps does it take?\n\n2. What happens if you call Euclid's algorithm with m < n? Does it still work?\n\n3. The **extended Euclidean algorithm** finds integers x and y such that gcd(m, n) = mx + ny. Research and implement it.\n\n4. Prove that for any n > 0, gcd(n, n) = n.\n\n5. What is the time complexity of an algorithm that examines all pairs in a list of n elements?\n\n"
    }
  ]
}