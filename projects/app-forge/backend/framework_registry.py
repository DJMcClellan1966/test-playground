"""Framework Registry - Language/Stack-Specific Generators.

Each framework generator knows how to produce code for a specific
technology stack. The universal builder selects a generator based
on the app category and user preferences.

Current generators:
- Flask (Python web)
- FastAPI (Python async API)
- Click (Python CLI)
- HTML/Canvas (Browser games)
- sklearn_pipeline (ML)

Future generators:
- Express (Node.js)
- React (SPA frontend)
- .NET (C# API)
- Flutter (Mobile)
"""

from abc import ABC
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

from universal_builder import (
    FrameworkGenerator, ProjectFile, Component, 
    AppCategory, universal_builder
)

# Import existing domain parser
try:
    from domain_parser import DomainModel
except ImportError:
    @dataclass
    class DomainModel:
        name: str
        fields: List[tuple]


# =====================================================================
# Flask Generator (Data Apps, Simple APIs)
# =====================================================================

class FlaskGenerator(FrameworkGenerator):
    """Generate Flask applications."""
    
    id = "flask"
    name = "Flask"
    language = "python"
    categories = [AppCategory.DATA_APP, AppCategory.API_SERVICE]
    
    def generate(self, app_name: str, models: List[DomainModel],
                 components: List[Component], answers: Dict[str, Any],
                 description: str) -> List[ProjectFile]:
        files = []
        
        # Main app.py
        files.append(ProjectFile(
            path="app.py",
            content=self._generate_app_py(app_name, models, components, answers, description)
        ))
        
        # Models
        if models or self._needs_database(components):
            files.append(ProjectFile(
                path="models.py",
                content=self._generate_models_py(models, components, answers)
            ))
        
        # Requirements
        files.append(ProjectFile(
            path="requirements.txt",
            content=self._generate_requirements(components, answers)
        ))
        
        # Index HTML
        files.append(ProjectFile(
            path="templates/index.html",
            content=self._generate_index_html(app_name, models, components, answers)
        ))
        
        return files
    
    def get_run_command(self, app_name: str) -> str:
        return "python app.py"
    
    def get_install_command(self) -> str:
        return "pip install -r requirements.txt"
    
    def _needs_database(self, components: List[Component]) -> bool:
        return any(c.id in ["database", "crud", "auth"] for c in components)
    
    def _generate_app_py(self, app_name: str, models: List[DomainModel],
                         components: List[Component], answers: Dict[str, Any],
                         description: str = "") -> str:
        comp_ids = {c.id for c in components}
        
        imports = ["from flask import Flask, render_template, request, jsonify, redirect, url_for"]
        
        if self._needs_database(components):
            imports.append("from flask_sqlalchemy import SQLAlchemy")
        if "auth" in comp_ids:
            imports.append("from flask import session")
            imports.append("from werkzeug.security import generate_password_hash, check_password_hash")
        if "websocket" in comp_ids:
            imports.append("from flask_socketio import SocketIO, emit")
        
        code = f'''"""
{app_name} - Generated by Universal App Builder
{description or ""}
"""

{chr(10).join(imports)}

app = Flask(__name__)
app.secret_key = 'change-this-in-production'
'''
        
        if self._needs_database(components):
            code += '''
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
'''
        
        if "websocket" in comp_ids:
            code += '''
socketio = SocketIO(app, cors_allowed_origins="*")
'''
        
        # Import models
        if models or self._needs_database(components):
            code += '''
from models import *
'''
        
        # Routes
        code += '''

@app.route('/')
def index():
    return render_template('index.html')
'''
        
        # CRUD routes
        if "crud" in comp_ids and models:
            for model in models:
                code += self._crud_routes(model, "auth" in comp_ids)
        
        # Auth routes
        if "auth" in comp_ids:
            code += self._auth_routes()
        
        # Search routes
        if "search" in comp_ids and models:
            code += self._search_routes(models)
        
        # Export routes
        if "export" in comp_ids and models:
            code += self._export_routes(models)
        
        # Main block
        code += '''

if __name__ == '__main__':
'''
        if self._needs_database(components):
            code += '''    with app.app_context():
        db.create_all()
'''
        
        if "websocket" in comp_ids:
            code += '''    socketio.run(app, debug=True)
'''
        else:
            code += '''    app.run(debug=True)
'''
        
        return code
    
    def _crud_routes(self, model: DomainModel, needs_auth: bool) -> str:
        name = model.name.lower()
        Name = model.name
        return f'''

# ----- {Name} CRUD -----
@app.route('/{name}s')
def list_{name}s():
    items = {Name}.query.all()
    return jsonify([item.to_dict() for item in items])

@app.route('/{name}s', methods=['POST'])
def create_{name}():
    data = request.json
    item = {Name}(**data)
    db.session.add(item)
    db.session.commit()
    return jsonify(item.to_dict()), 201

@app.route('/{name}s/<int:id>')
def get_{name}(id):
    item = {Name}.query.get_or_404(id)
    return jsonify(item.to_dict())

@app.route('/{name}s/<int:id>', methods=['PUT'])
def update_{name}(id):
    item = {Name}.query.get_or_404(id)
    data = request.json
    for key, value in data.items():
        setattr(item, key, value)
    db.session.commit()
    return jsonify(item.to_dict())

@app.route('/{name}s/<int:id>', methods=['DELETE'])
def delete_{name}(id):
    item = {Name}.query.get_or_404(id)
    db.session.delete(item)
    db.session.commit()
    return '', 204
'''
    
    def _auth_routes(self) -> str:
        return '''

# ----- Authentication -----
@app.route('/register', methods=['POST'])
def register():
    data = request.json
    if User.query.filter_by(username=data['username']).first():
        return jsonify({"error": "Username exists"}), 400
    user = User(
        username=data['username'],
        password=generate_password_hash(data['password'])
    )
    db.session.add(user)
    db.session.commit()
    return jsonify({"message": "Registered"}), 201

@app.route('/login', methods=['POST'])
def login():
    data = request.json
    user = User.query.filter_by(username=data['username']).first()
    if user and check_password_hash(user.password, data['password']):
        session['user_id'] = user.id
        return jsonify({"message": "Logged in"})
    return jsonify({"error": "Invalid credentials"}), 401

@app.route('/logout', methods=['POST'])
def logout():
    session.pop('user_id', None)
    return jsonify({"message": "Logged out"})
'''
    
    def _search_routes(self, models: List[DomainModel]) -> str:
        code = '''

# ----- Search -----
@app.route('/search')
def search():
    q = request.args.get('q', '')
    results = {}
'''
        for model in models:
            name = model.name.lower()
            Name = model.name
            code += f'''
    {name}_results = {Name}.query.filter({Name}.name.ilike(f'%{{q}}%')).all()
    results['{name}s'] = [item.to_dict() for item in {name}_results]
'''
        code += '''
    return jsonify(results)
'''
        return code
    
    def _export_routes(self, models: List[DomainModel]) -> str:
        return f'''

# ----- Export -----
@app.route('/export/<model_name>')
def export_data(model_name):
    import csv
    from io import StringIO
    from flask import Response
    
    model_map = {{{', '.join(f'"{m.name.lower()}": {m.name}' for m in models)}}}
    
    if model_name not in model_map:
        return jsonify({{"error": "Unknown model"}}), 404
    
    Model = model_map[model_name]
    items = Model.query.all()
    
    output = StringIO()
    if items:
        writer = csv.DictWriter(output, fieldnames=items[0].to_dict().keys())
        writer.writeheader()
        for item in items:
            writer.writerow(item.to_dict())
    
    return Response(
        output.getvalue(),
        mimetype='text/csv',
        headers={{'Content-Disposition': f'attachment;filename={{model_name}}.csv'}}
    )
'''
    
    def _generate_models_py(self, models: List[DomainModel],
                            components: List[Component], answers: Dict[str, Any]) -> str:
        comp_ids = {c.id for c in components}
        
        code = '''"""Database models."""

from app import db
from datetime import datetime

'''
        # User model for auth
        if "auth" in comp_ids:
            code += '''
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def to_dict(self):
        return {"id": self.id, "username": self.username}

'''
        
        # Domain models
        for model in models:
            code += self._model_class(model, "auth" in comp_ids)
        
        return code
    
    def _model_class(self, model: DomainModel, has_auth: bool) -> str:
        Name = model.name
        fields = model.fields if hasattr(model, 'fields') else []
        
        code = f'''
class {Name}(db.Model):
    id = db.Column(db.Integer, primary_key=True)
'''
        if has_auth:
            code += f'''    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
'''
        
        for field_name, field_type, *_ in fields:
            col_type = "db.String(200)"
            if field_type == "int":
                col_type = "db.Integer"
            elif field_type == "float":
                col_type = "db.Float"
            elif field_type == "bool":
                col_type = "db.Boolean"
            elif field_type == "date":
                col_type = "db.Date"
            elif field_type == "text":
                col_type = "db.Text"
            code += f'''    {field_name} = db.Column({col_type})
'''
        
        code += f'''    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    def to_dict(self):
        return {{
            "id": self.id,
'''
        for field_name, *_ in fields:
            code += f'''            "{field_name}": self.{field_name},
'''
        code += f'''            "created_at": self.created_at.isoformat() if self.created_at else None
        }}

'''
        return code
    
    def _generate_requirements(self, components: List[Component],
                               answers: Dict[str, Any]) -> str:
        reqs = ["flask==3.0.2", "flask-cors==4.0.0"]
        comp_ids = {c.id for c in components}
        
        if self._needs_database(components):
            reqs.append("flask-sqlalchemy==3.1.1")
        if "websocket" in comp_ids:
            reqs.append("flask-socketio==5.3.6")
        
        return "\n".join(reqs) + "\n"
    
    def _generate_index_html(self, app_name: str, models: List[DomainModel],
                             components: List[Component], answers: Dict[str, Any]) -> str:
        return f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{app_name}</title>
    <style>
        * {{ box-sizing: border-box; margin: 0; padding: 0; }}
        body {{ font-family: system-ui, sans-serif; background: #f5f5f5; padding: 2rem; }}
        .container {{ max-width: 800px; margin: 0 auto; }}
        h1 {{ color: #333; margin-bottom: 1rem; }}
        .card {{ background: white; padding: 1.5rem; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 1rem; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>{app_name}</h1>
        <div class="card">
            <p>Welcome to {app_name}!</p>
            <p>Generated by Universal App Builder</p>
        </div>
    </div>
</body>
</html>
'''


# =====================================================================
# FastAPI Generator (Async APIs)
# =====================================================================

class FastAPIGenerator(FrameworkGenerator):
    """Generate FastAPI applications."""
    
    id = "fastapi"
    name = "FastAPI"
    language = "python"
    categories = [AppCategory.API_SERVICE, AppCategory.ML_PIPELINE]
    
    def generate(self, app_name: str, models: List[DomainModel],
                 components: List[Component], answers: Dict[str, Any],
                 description: str) -> List[ProjectFile]:
        files = []
        
        files.append(ProjectFile(
            path="main.py",
            content=self._generate_main_py(app_name, models, components, answers, description)
        ))
        
        files.append(ProjectFile(
            path="schemas.py",
            content=self._generate_schemas_py(models)
        ))
        
        files.append(ProjectFile(
            path="requirements.txt",
            content=self._generate_requirements(components)
        ))
        
        return files
    
    def get_run_command(self, app_name: str) -> str:
        return "uvicorn main:app --reload"
    
    def get_install_command(self) -> str:
        return "pip install -r requirements.txt"
    
    def _generate_main_py(self, app_name: str, models: List[DomainModel],
                          components: List[Component], answers: Dict[str, Any],
                          description: str) -> str:
        comp_ids = {c.id for c in components}
        
        return f'''"""
{app_name} - FastAPI Application
{description or ""}
Generated by Universal App Builder
"""

from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Optional
from pydantic import BaseModel
from datetime import datetime

app = FastAPI(
    title="{app_name}",
    description="{description or 'Generated API'}",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# In-memory storage (replace with database)
storage = {{}}

@app.get("/")
async def root():
    return {{"message": "Welcome to {app_name}", "docs": "/docs"}}

@app.get("/health")
async def health():
    return {{"status": "healthy", "timestamp": datetime.utcnow().isoformat()}}
'''
    
    def _generate_schemas_py(self, models: List[DomainModel]) -> str:
        code = '''"""Pydantic schemas for request/response validation."""

from pydantic import BaseModel
from typing import Optional
from datetime import datetime

'''
        for model in models:
            Name = model.name
            fields = model.fields if hasattr(model, 'fields') else []
            
            code += f'''
class {Name}Base(BaseModel):
'''
            for field_name, field_type, *_ in fields:
                py_type = "str"
                if field_type == "int":
                    py_type = "int"
                elif field_type == "float":
                    py_type = "float"
                elif field_type == "bool":
                    py_type = "bool"
                code += f'''    {field_name}: {py_type}
'''
            
            code += f'''
class {Name}Create({Name}Base):
    pass

class {Name}Response({Name}Base):
    id: int
    created_at: datetime
    
    class Config:
        from_attributes = True

'''
        return code
    
    def _generate_requirements(self, components: List[Component]) -> str:
        return """fastapi==0.109.0
uvicorn==0.27.0
pydantic==2.6.0
python-multipart==0.0.6
"""


# =====================================================================
# Click CLI Generator
# =====================================================================

class ClickGenerator(FrameworkGenerator):
    """Generate Click CLI applications."""
    
    id = "click"
    name = "Click CLI"
    language = "python"
    categories = [AppCategory.CLI_TOOL]
    
    def generate(self, app_name: str, models: List[DomainModel],
                 components: List[Component], answers: Dict[str, Any],
                 description: str) -> List[ProjectFile]:
        
        has_subcommands = answers.get("subcommands") == "Yes"
        
        files = [
            ProjectFile(
                path="cli.py",
                content=self._generate_cli_py(app_name, components, answers, description, has_subcommands)
            ),
            ProjectFile(
                path="requirements.txt",
                content=self._generate_requirements(components)
            ),
        ]
        
        return files
    
    def get_run_command(self, app_name: str) -> str:
        return "python cli.py --help"
    
    def get_install_command(self) -> str:
        return "pip install -r requirements.txt"
    
    def _generate_cli_py(self, app_name: str, components: List[Component],
                         answers: Dict[str, Any], description: str,
                         has_subcommands: bool) -> str:
        
        app_name_snake = app_name.lower().replace(" ", "_")
        comp_ids = {c.id for c in components}
        
        imports = ["import click"]
        if "progress_bar" in comp_ids:
            imports.append("from tqdm import tqdm")
        if "rich_output" in comp_ids:
            imports.append("from rich.console import Console")
            imports.append("from rich.table import Table")
        
        code = f'''#!/usr/bin/env python3
"""
{app_name} - Command Line Tool
{description or ""}
Generated by Universal App Builder
"""

{chr(10).join(imports)}

'''
        
        if "rich_output" in comp_ids:
            code += '''console = Console()

'''
        
        if has_subcommands:
            code += f'''@click.group()
@click.version_option(version='1.0.0')
def cli():
    """{description or app_name}"""
    pass


@cli.command()
@click.argument('name')
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
def hello(name, verbose):
    """Say hello to NAME."""
    if verbose:
        click.echo(f'Debug: Processing name={{name}}')
    click.echo(f'Hello, {{name}}!')


@cli.command()
@click.option('--count', '-c', default=1, help='Number of times to repeat')
def example(count):
    """Run the example command."""
    for i in range(count):
        click.echo(f'Running example iteration {{i+1}}')


if __name__ == '__main__':
    cli()
'''
        else:
            code += f'''@click.command()
@click.argument('input_file', type=click.Path(exists=True))
@click.option('--output', '-o', default=None, help='Output file path')
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
def main(input_file, output, verbose):
    """
    {description or app_name}
    
    Process INPUT_FILE and optionally write to OUTPUT.
    """
    if verbose:
        click.echo(f'Processing: {{input_file}}')
    
    # TODO: Add your processing logic here
    click.echo('Processing complete!')
    
    if output:
        click.echo(f'Output written to: {{output}}')


if __name__ == '__main__':
    main()
'''
        
        return code
    
    def _generate_requirements(self, components: List[Component]) -> str:
        reqs = ["click==8.1.7"]
        comp_ids = {c.id for c in components}
        
        if "progress_bar" in comp_ids:
            reqs.append("tqdm==4.66.1")
        if "rich_output" in comp_ids:
            reqs.append("rich==13.7.0")
        
        return "\n".join(reqs) + "\n"


# =====================================================================
# HTML Canvas Generator (Games)
# =====================================================================

class HTMLCanvasGenerator(FrameworkGenerator):
    """Generate HTML5 Canvas games."""
    
    id = "html_canvas"
    name = "HTML5 Canvas"
    language = "javascript"
    categories = [AppCategory.GAME]
    
    def generate(self, app_name: str, models: List[DomainModel],
                 components: List[Component], answers: Dict[str, Any],
                 description: str) -> List[ProjectFile]:
        
        return [
            ProjectFile(
                path="index.html",
                content=self._generate_html(app_name, components, answers, description)
            )
        ]
    
    def get_run_command(self, app_name: str) -> str:
        return "open index.html  # or use a local server"
    
    def _generate_html(self, app_name: str, components: List[Component],
                       answers: Dict[str, Any], description: str) -> str:
        comp_ids = {c.id for c in components}
        
        return f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{app_name}</title>
    <style>
        * {{ box-sizing: border-box; margin: 0; padding: 0; }}
        body {{
            font-family: system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
        }}
        #gameContainer {{
            text-align: center;
        }}
        h1 {{
            font-size: 2rem;
            margin-bottom: 1rem;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }}
        #canvas {{
            background: #0f0f23;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }}
        #score {{
            font-size: 1.5rem;
            margin: 1rem 0;
        }}
        #gameOver {{
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
        }}
        button {{
            padding: 0.75rem 2rem;
            font-size: 1rem;
            border: none;
            border-radius: 6px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            margin-top: 1rem;
        }}
        button:hover {{
            background: #45a049;
        }}
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>{app_name}</h1>
        <canvas id="canvas" width="400" height="400"></canvas>
        <div id="score">Score: <span id="scoreValue">0</span></div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="restart()">Play Again</button>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let score = 0;
        let gameOver = false;
        
        // Game state
        let state = {{}};
        
        function init() {{
            score = 0;
            gameOver = false;
            document.getElementById('scoreValue').textContent = '0';
            document.getElementById('gameOver').style.display = 'none';
            
            // Initialize your game state here
            state = {{
                x: canvas.width / 2,
                y: canvas.height / 2,
            }};
        }}
        
        function update() {{
            if (gameOver) return;
            
            // Update game logic here
        }}
        
        function render() {{
            // Clear canvas
            ctx.fillStyle = '#0f0f23';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw game objects here
            ctx.fillStyle = '#4CAF50';
            ctx.beginPath();
            ctx.arc(state.x, state.y, 20, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw instructions
            ctx.fillStyle = '#666';
            ctx.font = '14px system-ui';
            ctx.fillText('Add your game logic!', canvas.width/2 - 70, canvas.height - 20);
        }}
        
        function showGameOver() {{
            gameOver = true;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }}
        
        function updateScore(points) {{
            score += points;
            document.getElementById('scoreValue').textContent = score;
        }}
        
        function restart() {{
            init();
            render();
        }}
        
        // Input handling
        document.addEventListener('keydown', e => {{
            if (gameOver) return;
            
            const speed = 10;
            switch(e.key) {{
                case 'ArrowUp': state.y -= speed; break;
                case 'ArrowDown': state.y += speed; break;
                case 'ArrowLeft': state.x -= speed; break;
                case 'ArrowRight': state.x += speed; break;
            }}
            render();
        }});
        
        canvas.addEventListener('click', e => {{
            if (gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            state.x = e.clientX - rect.left;
            state.y = e.clientY - rect.top;
            updateScore(10);
            render();
        }});
        
        // Game loop
        function gameLoop() {{
            update();
            render();
            if (!gameOver) requestAnimationFrame(gameLoop);
        }}
        
        // Start
        init();
        gameLoop();
    </script>
</body>
</html>
'''


# =====================================================================
# Sklearn Pipeline Generator (ML)
# =====================================================================

class SklearnPipelineGenerator(FrameworkGenerator):
    """Generate scikit-learn ML pipelines."""
    
    id = "sklearn_pipeline"
    name = "Scikit-learn Pipeline"
    language = "python"
    categories = [AppCategory.ML_PIPELINE]
    
    def generate(self, app_name: str, models: List[DomainModel],
                 components: List[Component], answers: Dict[str, Any],
                 description: str) -> List[ProjectFile]:
        
        ml_task = answers.get("ml_task", "Classification")
        
        files = [
            ProjectFile(
                path="train.py",
                content=self._generate_train_py(app_name, ml_task, answers, description)
            ),
            ProjectFile(
                path="predict.py",
                content=self._generate_predict_py(app_name, ml_task)
            ),
            ProjectFile(
                path="requirements.txt",
                content=self._generate_requirements(components, answers)
            ),
        ]
        
        if answers.get("serve_model") == "Yes":
            files.append(ProjectFile(
                path="serve.py",
                content=self._generate_serve_py(app_name)
            ))
        
        return files
    
    def get_run_command(self, app_name: str) -> str:
        return "python train.py"
    
    def get_install_command(self) -> str:
        return "pip install -r requirements.txt"
    
    def _generate_train_py(self, app_name: str, ml_task: str,
                           answers: Dict[str, Any], description: str) -> str:
        
        if ml_task == "Classification":
            model_import = "from sklearn.ensemble import RandomForestClassifier"
            model_class = "RandomForestClassifier(n_estimators=100, random_state=42)"
            metric = "accuracy_score"
        elif ml_task == "Regression":
            model_import = "from sklearn.ensemble import RandomForestRegressor"
            model_class = "RandomForestRegressor(n_estimators=100, random_state=42)"
            metric = "mean_squared_error"
        else:
            model_import = "from sklearn.cluster import KMeans"
            model_class = "KMeans(n_clusters=3, random_state=42)"
            metric = "silhouette_score"
        
        return f'''"""
{app_name} - Training Pipeline
{description or ""}
Generated by Universal App Builder
"""

import pandas as pd
import numpy as np
import joblib
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.metrics import {metric}
{model_import}


def load_data(path: str = 'data.csv'):
    """Load and preprocess the dataset."""
    df = pd.read_csv(path)
    print(f"Loaded {{len(df)}} samples with {{len(df.columns)}} features")
    return df


def create_pipeline():
    """Create the ML pipeline."""
    return Pipeline([
        ('scaler', StandardScaler()),
        ('model', {model_class}),
    ])


def train(data_path: str = 'data.csv', target_col: str = 'target'):
    """Train the model."""
    # Load data
    df = load_data(data_path)
    
    X = df.drop(columns=[target_col])
    y = df[target_col]
    
    # Split
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )
    
    # Train
    pipeline = create_pipeline()
    pipeline.fit(X_train, y_train)
    
    # Evaluate
    y_pred = pipeline.predict(X_test)
    score = {metric}(y_test, y_pred)
    print(f"Test {metric}: {{score:.4f}}")
    
    # Save
    joblib.dump(pipeline, 'model.joblib')
    print("Model saved to model.joblib")
    
    return pipeline, score


if __name__ == '__main__':
    train()
'''
    
    def _generate_predict_py(self, app_name: str, ml_task: str) -> str:
        return f'''"""
{app_name} - Prediction Script
"""

import pandas as pd
import joblib
import sys


def predict(input_path: str, output_path: str = None):
    """Make predictions on new data."""
    # Load model
    pipeline = joblib.load('model.joblib')
    
    # Load data
    df = pd.read_csv(input_path)
    print(f"Making predictions on {{len(df)}} samples...")
    
    # Predict
    predictions = pipeline.predict(df)
    
    # Output
    df['prediction'] = predictions
    
    if output_path:
        df.to_csv(output_path, index=False)
        print(f"Predictions saved to {{output_path}}")
    else:
        print(df[['prediction']].head(10))
    
    return predictions


if __name__ == '__main__':
    input_file = sys.argv[1] if len(sys.argv) > 1 else 'test_data.csv'
    output_file = sys.argv[2] if len(sys.argv) > 2 else None
    predict(input_file, output_file)
'''
    
    def _generate_serve_py(self, app_name: str) -> str:
        return f'''"""
{app_name} - Model Serving API
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import joblib
import numpy as np

app = FastAPI(title="{app_name} API")

# Load model at startup
model = None

@app.on_event("startup")
def load_model():
    global model
    model = joblib.load('model.joblib')
    print("Model loaded")


class PredictionRequest(BaseModel):
    features: list[float]


class PredictionResponse(BaseModel):
    prediction: float
    confidence: float = None


@app.post("/predict", response_model=PredictionResponse)
def predict(request: PredictionRequest):
    if model is None:
        raise HTTPException(status_code=500, detail="Model not loaded")
    
    X = np.array([request.features])
    prediction = model.predict(X)[0]
    
    # Get probability if classifier
    confidence = None
    if hasattr(model, 'predict_proba'):
        proba = model.predict_proba(X)[0]
        confidence = float(max(proba))
    
    return PredictionResponse(
        prediction=float(prediction),
        confidence=confidence
    )


@app.get("/health")
def health():
    return {{"status": "healthy", "model_loaded": model is not None}}


if __name__ == '__main__':
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
'''
    
    def _generate_requirements(self, components: List[Component],
                               answers: Dict[str, Any]) -> str:
        reqs = [
            "scikit-learn==1.4.0",
            "pandas==2.2.0",
            "numpy==1.26.3",
            "joblib==1.3.2",
        ]
        
        if answers.get("serve_model") == "Yes":
            reqs.extend(["fastapi==0.109.0", "uvicorn==0.27.0"])
        
        return "\n".join(reqs) + "\n"


# =====================================================================
# Registration
# =====================================================================

GENERATORS = [
    FlaskGenerator(),
    FastAPIGenerator(),
    ClickGenerator(),
    HTMLCanvasGenerator(),
    SklearnPipelineGenerator(),
]


def register_all_frameworks():
    """Register all framework generators with the universal builder."""
    for generator in GENERATORS:
        universal_builder.register_framework(generator)


# Auto-register on import
register_all_frameworks()


# =====================================================================
# Testing
# =====================================================================

if __name__ == "__main__":
    print("Framework Registry")
    print("=" * 60)
    
    for gen in GENERATORS:
        cats = ", ".join(c.value for c in gen.categories)
        print(f"  {gen.id:20} ({gen.language:10}) â†’ {cats}")
    
    print("\nTest: Generate Flask app")
    flask_gen = FlaskGenerator()
    
    # Mock domain model
    @dataclass
    class MockModel:
        name: str
        fields: list
    
    models = [MockModel("Recipe", [("name", "str"), ("ingredients", "text")])]
    components = [
        universal_builder.component_library.get("crud"),
        universal_builder.component_library.get("database"),
    ]
    
    files = flask_gen.generate(
        app_name="RecipeApp",
        models=models,
        components=[c for c in components if c],
        answers={"has_data": True},
        description="A recipe collection app"
    )
    
    print(f"\nGenerated {len(files)} files:")
    for f in files:
        print(f"  {f.path} ({len(f.content)} chars)")
